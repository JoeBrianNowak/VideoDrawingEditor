<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C64 Audio Encoder/Decoder FSK</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 2px;
        }

        .subtitle {
            text-align: center;
            opacity: 0.9;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .sections {
                grid-template-columns: 1fr;
            }
        }

        .section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
        }

        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.95em;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: rgba(76, 175, 80, 0.6);
            border-color: rgba(76, 175, 80, 0.8);
        }

        button.primary:hover:not(:disabled) {
            background: rgba(76, 175, 80, 0.8);
        }

        button.danger {
            background: rgba(244, 67, 54, 0.6);
            border-color: rgba(244, 67, 54, 0.8);
        }

        button.danger:hover:not(:disabled) {
            background: rgba(244, 67, 54, 0.8);
        }

        button.recording {
            background: rgba(244, 67, 54, 0.8);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .file-input-label:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .player {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85em;
            font-weight: bold;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 0.9em;
            min-height: 40px;
        }

        .waveform {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ C64 AUDIO CODEC üéµ</h1>
        <p class="subtitle">Sistema di codifica/decodifica FSK stile Commodore 64</p>

        <div class="sections">
            <!-- SEZIONE ENCODE -->
            <div class="section">
                <h2>üéôÔ∏è ENCODE</h2>
                
                <div class="control-group">
                    <label>Registra o Carica Audio:</label>
                    <button id="recordBtn" class="primary">üî¥ Inizia Registrazione</button>
                    <label for="audioFile" class="file-input-label">üìÅ Carica File Audio</label>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>

                <div id="encodePlayer" class="player hidden">
                    <div class="player-controls">
                        <button id="encPlayBtn">‚ñ∂Ô∏è Play</button>
                        <button id="encStopBtn">‚èπÔ∏è Stop</button>
                        <input type="range" id="encVolume" min="0" max="100" value="80">
                        <span id="encVolumeLabel">80%</span>
                    </div>
                    <canvas id="encWaveform" class="waveform"></canvas>
                </div>

                <div class="control-group">
                    <button id="encodeBtn" class="primary" disabled>‚ö° Codifica in FSK</button>
                    <button id="cancelEncodeBtn" class="danger hidden">‚ùå Annulla</button>
                </div>

                <div id="encodeProgress" class="progress-bar hidden">
                    <div id="encodeProgressFill" class="progress-fill">0%</div>
                </div>

                <div id="encodeStatus" class="status">In attesa di audio...</div>

                <div class="control-group">
                    <button id="saveEncodedBtn" class="primary" disabled>üíæ Salva File Codificato</button>
                </div>

                <div class="info-box">
                    <strong>FSK Parameters:</strong><br>
                    ‚Ä¢ Bit 0: 1200 Hz<br>
                    ‚Ä¢ Bit 1: 2400 Hz<br>
                    ‚Ä¢ Sample Rate: 44100 Hz<br>
                    ‚Ä¢ Bit Duration: ~368 Œºs
                </div>
            </div>

            <!-- SEZIONE DECODE -->
            <div class="section">
                <h2>üîä DECODE</h2>
                
                <div class="control-group">
                    <label>Carica File Codificato:</label>
                    <label for="encodedFile" class="file-input-label">üìÅ Carica File FSK</label>
                    <input type="file" id="encodedFile" accept="audio/*">
                </div>

                <div class="control-group">
                    <button id="decodeBtn" class="primary" disabled>üîì Decodifica Audio</button>
                    <button id="cancelDecodeBtn" class="danger hidden">‚ùå Annulla</button>
                </div>

                <div id="decodeProgress" class="progress-bar hidden">
                    <div id="decodeProgressFill" class="progress-fill">0%</div>
                </div>

                <div id="decodeStatus" class="status">In attesa di file codificato...</div>

                <div id="decodePlayer" class="player hidden">
                    <div class="player-controls">
                        <button id="decPlayBtn">‚ñ∂Ô∏è Play</button>
                        <button id="decStopBtn">‚èπÔ∏è Stop</button>
                        <input type="range" id="decVolume" min="0" max="100" value="80">
                        <span id="decVolumeLabel">80%</span>
                    </div>
                    <canvas id="decWaveform" class="waveform"></canvas>
                </div>

                <div class="control-group">
                    <button id="saveDecodedBtn" class="primary" disabled>üíæ Salva File Decodificato</button>
                </div>

                <div class="info-box">
                    <strong>Decodifica:</strong><br>
                    Il file FSK viene analizzato per estrarre le frequenze 1200/2400 Hz e ricostruire l'audio originale.<br>
                    <em>Simile al sistema Commodore Datasette!</em>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variabili globali
        let audioContext;
        let mediaRecorder;
        let audioChunks = [];
        let sourceAudioBuffer = null;
        let encodedAudioBuffer = null;
        let decodedAudioBuffer = null;
        let encodeSource = null;
        let decodeSource = null;
        let isRecording = false;
        let cancelEncode = false;
        let cancelDecode = false;

        // Parametri FSK
        const FREQ_0 = 1200;  // Frequenza per bit 0
        const FREQ_1 = 2400;  // Frequenza per bit 1
        const SAMPLE_RATE = 44100;
        const BIT_DURATION = 0.000368; // ~368 microsecondi (simile C64)
        const SAMPLES_PER_BIT = Math.floor(SAMPLE_RATE * BIT_DURATION);

        // Inizializza AudioContext
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // REGISTRAZIONE AUDIO
        document.getElementById('recordBtn').addEventListener('click', async () => {
            const btn = document.getElementById('recordBtn');
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        audioChunks.push(e.data);
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        initAudioContext();
                        sourceAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        loadSourceAudio();
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    btn.textContent = '‚èπÔ∏è Stop Registrazione';
                    btn.classList.add('recording');
                    updateStatus('encodeStatus', 'üî¥ Registrazione in corso...');
                } catch (err) {
                    updateStatus('encodeStatus', '‚ùå Errore: ' + err.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                btn.textContent = 'üî¥ Inizia Registrazione';
                btn.classList.remove('recording');
                updateStatus('encodeStatus', '‚úÖ Registrazione completata!');
            }
        });

        // CARICAMENTO FILE AUDIO
        document.getElementById('audioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const arrayBuffer = await file.arrayBuffer();
                initAudioContext();
                try {
                    sourceAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    loadSourceAudio();
                    updateStatus('encodeStatus', `‚úÖ File caricato: ${file.name}`);
                } catch (err) {
                    updateStatus('encodeStatus', '‚ùå Errore nel caricamento del file');
                }
            }
        });

        function loadSourceAudio() {
            document.getElementById('encodePlayer').classList.remove('hidden');
            document.getElementById('encodeBtn').disabled = false;
            drawWaveform('encWaveform', sourceAudioBuffer);
        }

        // PLAYER ENCODE
        document.getElementById('encPlayBtn').addEventListener('click', () => {
            if (sourceAudioBuffer) {
                playAudio(sourceAudioBuffer, 'encode');
            }
        });

        document.getElementById('encStopBtn').addEventListener('click', () => {
            stopAudio('encode');
        });

        document.getElementById('encVolume').addEventListener('input', (e) => {
            document.getElementById('encVolumeLabel').textContent = e.target.value + '%';
            if (encodeSource) {
                encodeSource.gainNode.gain.value = e.target.value / 100;
            }
        });

        // CODIFICA FSK
        document.getElementById('encodeBtn').addEventListener('click', async () => {
            cancelEncode = false;
            document.getElementById('encodeBtn').disabled = true;
            document.getElementById('cancelEncodeBtn').classList.remove('hidden');
            document.getElementById('encodeProgress').classList.remove('hidden');
            
            updateStatus('encodeStatus', '‚öôÔ∏è Codifica in corso...');
            
            try {
                encodedAudioBuffer = await encodeToFSK(sourceAudioBuffer);
                if (!cancelEncode) {
                    updateStatus('encodeStatus', '‚úÖ Codifica completata!');
                    document.getElementById('saveEncodedBtn').disabled = false;
                }
            } catch (err) {
                updateStatus('encodeStatus', '‚ùå Errore: ' + err.message);
            }
            
            document.getElementById('encodeBtn').disabled = false;
            document.getElementById('cancelEncodeBtn').classList.add('hidden');
        });

        document.getElementById('cancelEncodeBtn').addEventListener('click', () => {
            cancelEncode = true;
            updateStatus('encodeStatus', '‚ö†Ô∏è Codifica annullata');
            document.getElementById('encodeProgress').classList.add('hidden');
        });

        async function encodeToFSK(audioBuffer) {
            const channelData = audioBuffer.getChannelData(0);
            const duration = audioBuffer.duration;
            
            // Converti audio in byte
            const bytes = audioToBytes(channelData);
            
            // Crea buffer per FSK
            const totalBits = bytes.length * 8;
            const fskSamples = totalBits * SAMPLES_PER_BIT;
            const fskBuffer = audioContext.createBuffer(1, fskSamples, SAMPLE_RATE);
            const fskData = fskBuffer.getChannelData(0);
            
            let sampleIndex = 0;
            
            for (let i = 0; i < bytes.length; i++) {
                if (cancelEncode) throw new Error('Annullato');
                
                const byte = bytes[i];
                
                for (let bit = 7; bit >= 0; bit--) {
                    const bitValue = (byte >> bit) & 1;
                    const freq = bitValue ? FREQ_1 : FREQ_0;
                    
                    // Genera onda sinusoidale per il bit
                    for (let s = 0; s < SAMPLES_PER_BIT; s++) {
                        const t = s / SAMPLE_RATE;
                        fskData[sampleIndex++] = Math.sin(2 * Math.PI * freq * t) * 0.8;
                    }
                }
                
                // Aggiorna progresso
                const progress = ((i + 1) / bytes.length * 100).toFixed(1);
                updateProgress('encodeProgressFill', progress);
                
                // Permetti rendering UI
                if (i % 100 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            return fskBuffer;
        }

        function audioToBytes(channelData) {
            const bytes = [];
            for (let i = 0; i < channelData.length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                const byte = Math.floor((sample + 1) * 127.5);
                bytes.push(byte);
            }
            return bytes;
        }

        // SALVA FILE CODIFICATO
        document.getElementById('saveEncodedBtn').addEventListener('click', () => {
            if (encodedAudioBuffer) {
                const wav = audioBufferToWav(encodedAudioBuffer);
                downloadBlob(wav, 'encoded_fsk.wav');
                updateStatus('encodeStatus', 'üíæ File salvato!');
            }
        });

        // CARICAMENTO FILE CODIFICATO
        document.getElementById('encodedFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const arrayBuffer = await file.arrayBuffer();
                initAudioContext();
                try {
                    encodedAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    document.getElementById('decodeBtn').disabled = false;
                    updateStatus('decodeStatus', `‚úÖ File caricato: ${file.name}`);
                } catch (err) {
                    updateStatus('decodeStatus', '‚ùå Errore nel caricamento del file');
                }
            }
        });

        // DECODIFICA FSK
        document.getElementById('decodeBtn').addEventListener('click', async () => {
            cancelDecode = false;
            document.getElementById('decodeBtn').disabled = true;
            document.getElementById('cancelDecodeBtn').classList.remove('hidden');
            document.getElementById('decodeProgress').classList.remove('hidden');
            
            updateStatus('decodeStatus', '‚öôÔ∏è Decodifica in corso...');
            
            try {
                decodedAudioBuffer = await decodeFromFSK(encodedAudioBuffer);
                if (!cancelDecode) {
                    updateStatus('decodeStatus', '‚úÖ Decodifica completata!');
                    document.getElementById('decodePlayer').classList.remove('hidden');
                    document.getElementById('saveDecodedBtn').disabled = false;
                    drawWaveform('decWaveform', decodedAudioBuffer);
                }
            } catch (err) {
                updateStatus('decodeStatus', '‚ùå Errore: ' + err.message);
            }
            
            document.getElementById('decodeBtn').disabled = false;
            document.getElementById('cancelDecodeBtn').classList.add('hidden');
        });

        document.getElementById('cancelDecodeBtn').addEventListener('click', () => {
            cancelDecode = true;
            updateStatus('decodeStatus', '‚ö†Ô∏è Decodifica annullata');
            document.getElementById('decodeProgress').classList.add('hidden');
        });

        async function decodeFromFSK(fskBuffer) {
            const fskData = fskBuffer.getChannelData(0);
            const totalBits = Math.floor(fskData.length / SAMPLES_PER_BIT);
            const bytes = [];
            
            let bitIndex = 0;
            let currentByte = 0;
            let bitCount = 0;
            
            for (let i = 0; i < totalBits; i++) {
                if (cancelDecode) throw new Error('Annullato');
                
                const startSample = i * SAMPLES_PER_BIT;
                const endSample = startSample + SAMPLES_PER_BIT;
                
                // Analizza la frequenza dominante nel segmento
                const bit = detectBit(fskData, startSample, endSample);
                
                currentByte = (currentByte << 1) | bit;
                bitCount++;
                
                if (bitCount === 8) {
                    bytes.push(currentByte);
                    currentByte = 0;
                    bitCount = 0;
                }
                
                // Aggiorna progresso
                if (i % 8 === 0) {
                    const progress = ((i + 1) / totalBits * 100).toFixed(1);
                    updateProgress('decodeProgressFill', progress);
                    
                    if (i % 800 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            }
            
            // Converti bytes in audio
            return bytesToAudio(bytes);
        }

        function detectBit(data, start, end) {
            // Semplice rilevazione basata su zero-crossing
            let crossings = 0;
            for (let i = start + 1; i < end; i++) {
                if ((data[i - 1] < 0 && data[i] >= 0) || (data[i - 1] >= 0 && data[i] < 0)) {
                    crossings++;
                }
            }
            
            const avgCrossings = crossings / (end - start) * SAMPLE_RATE;
            return avgCrossings > 1800 ? 1 : 0;
        }

        function bytesToAudio(bytes) {
            const audioBuffer = audioContext.createBuffer(1, bytes.length, SAMPLE_RATE);
            const channelData = audioBuffer.getChannelData(0);
            
            for (let i = 0; i < bytes.length; i++) {
                channelData[i] = (bytes[i] / 127.5) - 1;
            }
            
            return audioBuffer;
        }

        // PLAYER DECODE
        document.getElementById('decPlayBtn').addEventListener('click', () => {
            if (decodedAudioBuffer) {
                playAudio(decodedAudioBuffer, 'decode');
            }
        });

        document.getElementById('decStopBtn').addEventListener('click', () => {
            stopAudio('decode');
        });

        document.getElementById('decVolume').addEventListener('input', (e) => {
            document.getElementById('decVolumeLabel').textContent = e.target.value + '%';
            if (decodeSource) {
                decodeSource.gainNode.gain.value = e.target.value / 100;
            }
        });

        // SALVA FILE DECODIFICATO
        document.getElementById('saveDecodedBtn').addEventListener('click', () => {
            if (decodedAudioBuffer) {
                const wav = audioBufferToWav(decodedAudioBuffer);
                downloadBlob(wav, 'decoded_audio.wav');
                updateStatus('decodeStatus', 'üíæ File salvato!');
            }
        });

        // FUNZIONI UTILITY
        function playAudio(buffer, type) {
            initAudioContext();
            stopAudio(type);
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = buffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const volume = type === 'encode' ? 
                document.getElementById('encVolume').value / 100 :
                document.getElementById('decVolume').value / 100;
            
            gainNode.gain.value = volume;
            source.start();
            
            if (type === 'encode') {
                encodeSource = { source, gainNode };
            } else {
                decodeSource = { source, gainNode };
            }
        }

        function stopAudio(type) {
            if (type === 'encode' && encodeSource) {
                encodeSource.source.stop();
                encodeSource = null;
            } else if (type === 'decode' && decodeSource) {
                decodeSource.source.stop();
                decodeSource = null;
            }
        }

        function drawWaveform(canvasId, buffer) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const data = buffer.getChannelData(0);
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const step = Math.ceil(data.length / canvas.width);
            const amp = canvas.height / 2;
            
            for (let i = 0; i < canvas.width; i++) {
                const min = Math.min(...data.slice(i * step, (i + 1) * step));
                const max = Math.max(...data.slice(i * step, (i + 1) * step));
                
                if (i === 0) {
                    ctx.moveTo(i, (1 + min) * amp);
                }
                ctx.lineTo(i, (1 + max) * amp);
                ctx.lineTo(i, (1 + min) * amp);
            }
            
            ctx.stroke();
        }

        function updateStatus(elementId, message) {
            document.getElementById(elementId).textContent = message;
        }

        function updateProgress(elementId, percent) {
            const element = document.getElementById(elementId);
            element.style.width = percent + '%';
            element.textContent = percent + '%';
        }

        function audioBufferToWav(buffer) {
            const length = buffer.length * buffer.numberOfChannels * 2 + 44;
            const arrayBuffer = new ArrayBuffer(length);
            const view = new DataView(arrayBuffer);
            const channels = [];
            let offset = 0;
            let pos = 0;

            // WAV header
            setUint32(0x46464952);
            setUint32(length - 8);
            setUint32(0x45564157);
            setUint32(0x20746d66);
            setUint32(16);
            setUint16(1);
            setUint16(buffer.numberOfChannels);
            setUint32(buffer.sampleRate);
            setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
            setUint16(buffer.numberOfChannels * 2);
            setUint16(16);
            setUint32(0x61746164);
            setUint32(length - pos - 4);

            for (let i = 0; i < buffer.numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            while (pos < length) {
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    const sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    pos += 2;
                }
                offset++;
            }

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }

            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
